import {
  type CountArgs,
  type CreateArgs,
  type CreateGlobalArgs,
  type CreateGlobalVersionArgs,
  type CreateVersionArgs,
  type DeleteManyArgs,
  type DeleteOneArgs,
  type DeleteVersionsArgs,
  type FindArgs,
  type FindGlobalArgs,
  type FindGlobalVersionsArgs,
  type FindOneArgs,
  type FindVersionsArgs,
  type PaginatedDocs,
  type QueryDraftsArgs,
  type SanitizedCollectionConfig,
  type TypeWithVersion,
  type UpdateGlobalArgs,
  type UpdateGlobalVersionArgs,
  type UpdateOneArgs,
  type UpdateVersionArgs,
  type TypeWithID,
  type Document,
  type Where,
  type BasePayload,
} from 'payload'

import { applicationDefault, initializeApp } from 'firebase-admin/app'
import { getFirestore, Firestore, Filter } from 'firebase-admin/firestore'
import { convertPayloadToFirestoreQuery, calculatePageResultStatistics } from './firestoreUtils'
import { generateQueryJson } from './firestoreQueryJsonConverter'
import type { FirestoreAdapter } from './types'

export function firestoreAdapter({
  defaultIDType = 'text',
  versionsSuffix,
}: {
  defaultIDType?: 'number' | 'text'
  versionsSuffix?: string
}) {
  function adapter({ payload }: { payload: BasePayload }) {
    return {
      name: 'firestore',
      packageName: 'payload-firestore-adapter',
      sessions: {},
      payload,
      defaultIDType,
      versionsSuffix: versionsSuffix || '_v',
      async create({
        data,
        collection: collectionName,
        draft,
        select,
        locale,
        req,
      }: CreateArgs): Promise<Document> {
        console.log('creating', collectionName, 'with data', data, 'and', {locale, draft, select})
        const colRef = (this.firestore as Firestore).collection(collectionName)
        // FIXME: maybe we can change this to use the autogenerated value - but we need data.id to be searchable, too for where queries
        data.id = crypto.randomUUID()
        data.createdAt = data.createdAt || new Date().toISOString()
        data.updatedAt = data.updatedAt || data.createdAt
        if (typeof data.document === 'undefined') {
          delete data.document
        }
        const docRef = colRef.doc('/' + data.id);
        await docRef.set(JSON.parse(JSON.stringify(data)));
        return { id: docRef.id, ...data }
      },

      async createGlobalVersion<T extends TypeWithID = TypeWithID>({
        autosave,
        createdAt,
        parent,
        updatedAt,
        versionData,
        req,
        select,
        globalSlug: payloadGlobalName,
        publishedLocale,
        snapshot,
      }: CreateGlobalVersionArgs<T>): Promise<TypeWithVersion<T>> {
        return await this.createVersion({
          autosave,
          collectionSlug: payloadGlobalName,
          createdAt,
          parent: parent || payloadGlobalName,
          req,
          select,
          updatedAt,
          versionData,
          publishedLocale,
          snapshot,
        })
      },
      async createVersion<T extends TypeWithID = TypeWithID>({
        autosave,
        collectionSlug,
        createdAt,
        parent,
        select,
        publishedLocale,
        snapshot,
        updatedAt,
        versionData,
      }: CreateVersionArgs<T>): Promise<TypeWithVersion<T>> {
        console.log(
          'creating version',
          collectionSlug,
          'for parent',
          parent,
          'with data',
          versionData,
          {select, publishedLocale, snapshot}
        )
        const colRef = (this.firestore as Firestore).collection(collectionSlug + this.versionsSuffix)
        // FIXME: maybe we can change this to use the autogenerated value - but we need data.id to be searchable, too for where queries
        let data: any = {
          id: crypto.randomUUID(),
          createdAt,
          updatedAt,
          parent,
          latest: true,
          version: versionData,
          autosave,
        }
        const docRef = colRef.doc('/' + data.id)
        console.log('creating version at', collectionSlug + this.versionsSuffix, data)
        await docRef.set(JSON.parse(JSON.stringify(data)))

        let previousLatestVersionDocs = await colRef.where(Filter.and(Filter.where('parent', '==', parent), Filter.where('latest', '==', true))).get();

        for (let previousLatestVersionDoc of previousLatestVersionDocs.docs) {
          if (previousLatestVersionDoc.id === data.id) {
            console.log('keep to latest for', previousLatestVersionDoc.id)
          } else {
            console.log('setting to nonlatest for', previousLatestVersionDoc.id)

            await previousLatestVersionDoc.ref.update({
              latest: false,
            })
          }
        }

        return { id: docRef.id, version: versionData, createdAt, parent, updatedAt }
      },
      async deleteMany({
        collection: collectionName,
        joins,
        where: payloadWhereQuery,
      }: DeleteManyArgs): Promise<void> {
        console.log('delete many from', collectionName,  {joins, where: payloadWhereQuery})
        const colRef = (this.firestore as Firestore).collection(collectionName)

        let firestoreQuery = colRef.limit(0);

        let collectionConfig = payload.collections[collectionName]?.config;

        // FIXME: maybe we can optimize if we search for just "one" item by id
        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            collectionName,
            collectionConfig,
            payloadWhereQuery,
          )
        }

        let docs = await firestoreQuery.get();
        let deletedDataItems = []
        for (let doc of docs.docs) {
          deletedDataItems.push(doc.data())
          await doc.ref.delete();
        }
      },
      async deleteOne({
        collection: collectionName,
        joins,
        select,
        where: payloadWhereQuery,
      }: DeleteOneArgs): Promise<any> {
        console.log('delete one from', collectionName, {joins, select, where: payloadWhereQuery});
        const colRef = (this.firestore as Firestore).collection(collectionName)

        let firestoreQuery = colRef.limit(1);

        let collectionConfig = payload.collections[collectionName]?.config;

        // FIXME: maybe we can optimize if we search for just "one" item by id
        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            collectionName,
            collectionConfig,
            payloadWhereQuery,
          );
          firestoreQuery = firestoreQuery.limit(1);
        }

        let docs = await firestoreQuery.get();
        let doc = docs.docs[0]

        let data = doc.data()

        for (let doc of docs.docs) {
          await doc.ref.delete();
        }

        return data
      },
      async deleteVersions({
        collection: nonVersionCollectionName,
        where: payloadWhereQuery,
        req,
        locale,
        sort,
      }: DeleteVersionsArgs): Promise<void> {
        console.log('deleting versions', nonVersionCollectionName, payloadWhereQuery, 'and', {locale, sort});
        let versionCollectionName = nonVersionCollectionName + this.versionsSuffix
        const colRef = (this.firestore as Firestore).collection(versionCollectionName)

        let firestoreQuery = colRef.limit(0);

        let collectionConfig = payload.collections[nonVersionCollectionName]?.config;

        if (!collectionConfig) {
          collectionConfig = payload.globals.config.find((global) => global.slug === nonVersionCollectionName) as unknown as SanitizedCollectionConfig;
        }

        // FIXME: maybe we can optimize if we search for just "one" item by id
        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            versionCollectionName,
            collectionConfig,
            payloadWhereQuery,
          )
        }

        let docs = await firestoreQuery.get();
        for (let doc of docs.docs) {
          console.log('delete version')
          await doc.ref.delete();
          console.log('deleted version')
        }
      },
      async find<T = TypeWithID>({
        collection: collectionName,
        limit: payloadLimit,
        locale,
        page,
        pagination,
        skip,
        sort,
        select,
        versions,
        where: payloadWhereQuery,
        joins,
        projection,
      }: FindArgs): Promise<PaginatedDocs<T>> {
        console.log('trying to find', collectionName, { joins, projection, versions, skip, locale, select })
        const colRef = (this.firestore as Firestore).collection(collectionName)

        let firestoreQuery = colRef.limit(0);

        let collectionConfig = payload.collections[collectionName]?.config;

        if (!sort) {
          console.log('no sort given');
          if (collectionConfig?.defaultSort) {
            console.log('found defaultSort', collectionConfig);
            sort = collectionConfig?.defaultSort;
          }
        }

        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            collectionName,
            collectionConfig,
            payloadWhereQuery,
            sort,
          )
        } else {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            collectionName,
            collectionConfig,
            null,
            sort,
          )
        }

        let totalDocsCount = (await firestoreQuery.count().get()).data().count;

        let offset = page || 1 > 1 ? (payloadLimit || 0) * ((page || 1) - 1) : 0

        if (payloadLimit) {
          // FIXME: offset in firestore means -> load everything until the limit + page and return just the last page.
          firestoreQuery = firestoreQuery.limit(payloadLimit);
        }
        if (offset > 0) {
          firestoreQuery = firestoreQuery.offset(offset);
        }

        console.log(generateQueryJson(firestoreQuery));

        let docs = await firestoreQuery.get()
        let dataItems = []

        // FIXME: offset in firestore means -> load everything until the limit + page and return just the last page.
        let rawDocs = docs.docs.slice(offset)

        for (let doc of rawDocs) {
          dataItems.push(doc.data() as T)
        }
        let { totalPages, nextPage, prevPage, pagingCounter, hasNextPage, hasPrevPage } =
          calculatePageResultStatistics({
            totalDocsCount,
            payloadLimit: payloadLimit ? payloadLimit : 0,
            page: page || 1,
            pagination: pagination || false,
          })
        console.log('fetched', collectionName, 'data', dataItems)

        return {
          docs: dataItems,
          hasNextPage,
          hasPrevPage,
          limit: payloadLimit || 0,
          pagingCounter,
          totalDocs: totalDocsCount,
          totalPages,
          nextPage,
          page: page || 1,
          prevPage,
        }
      },
      async findGlobalVersions<T = TypeWithID>({
        global: payloadGlobalName,
        req,
        limit,
        locale,
        page,
        select,
        pagination,
        skip,
        sort,
        where: payloadWhereQuery,
        versions,
      }: FindGlobalVersionsArgs): Promise<PaginatedDocs<TypeWithVersion<T>>> {
        return await this.findVersions({
          collection: payloadGlobalName,
          req,
          limit,
          locale,
          page,
          select,
          pagination,
          skip,
          sort,
          versions,
          where: payloadWhereQuery,
        })
      },
      async countVersions<T = TypeWithID>({
        collection: nonVersionCollectionName,
        req,
        locale,
        where: payloadWhereQuery,
      }: any): Promise<any> {
        let versionCollectionName = nonVersionCollectionName + this.versionsSuffix
        console.log('trying to count versions', versionCollectionName, {locale})

        const colRef = (this.firestore as Firestore).collection(versionCollectionName);
        let firestoreQuery = colRef.limit(0);

        let collectionConfig = payload.collections[nonVersionCollectionName]?.config;

        if (!collectionConfig) {
          collectionConfig = payload.globals.config.find((global) => global.slug === nonVersionCollectionName) as unknown as SanitizedCollectionConfig;
        }

        payload.globals

        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            versionCollectionName,
            collectionConfig,
            payloadWhereQuery,
            null,
          )
        } else {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            versionCollectionName,
            collectionConfig,
            null,
            null,
          )
        }

        let totalDocsCount = (await (firestoreQuery.count().get())).data().count;

        return {
          totalDocs: totalDocsCount
        }
      },
      async findVersions<T = TypeWithID>({
        collection: nonVersionCollectionName,
        limit: payloadLimit,
        locale,
        page,
        select,
        pagination,
        skip,
        sort,
        versions,
        where: payloadWhereQuery,
      }: FindVersionsArgs): Promise<PaginatedDocs<TypeWithVersion<T>>> {
        let versionCollectionName = nonVersionCollectionName + this.versionsSuffix
        console.log('trying to find versions', versionCollectionName, {locale, versions, select})

        const colRef = (this.firestore as Firestore).collection(versionCollectionName);
        let firestoreQuery = colRef.limit(0);

        let collectionConfig = payload.collections[nonVersionCollectionName]?.config;

        if (!collectionConfig) {
          collectionConfig = payload.globals.config.find((global) => global.slug === nonVersionCollectionName) as unknown as SanitizedCollectionConfig;
        }

        if (!sort) {
          console.log('no sort given');
          if (collectionConfig?.defaultSort) {
            console.log('found defaultSort', collectionConfig);
            sort = collectionConfig?.defaultSort;
          }
        }

        payload.globals

        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            versionCollectionName,
            collectionConfig,
            payloadWhereQuery,
            sort,
          )
        } else {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            versionCollectionName,
            collectionConfig,
            null,
            sort,
          )
        }

        let totalDocsCount = (await (firestoreQuery.count().get())).data().count;

        let offset = (skip || 0) + (page || 1 > 1 ? (payloadLimit || 0) * ((page || 1) - 1) : 0)

        if (payloadLimit) {
          // FIXME: offset in firestore means -> load everything until the limit + page and return just the last page.
          if (offset > 0) {
            firestoreQuery = firestoreQuery.limit(payloadLimit + offset);
            firestoreQuery = firestoreQuery.offset(offset);
          } else {
            firestoreQuery = firestoreQuery.limit(payloadLimit);
          }
        } else {
          if (offset > 0) {
            firestoreQuery = firestoreQuery.offset(offset);
          }
        }

        console.log('searching versions', generateQueryJson(firestoreQuery))

        let docs = await firestoreQuery.get();
        let dataItems = []

        let rawDocs = docs.docs;

        for (let doc of rawDocs) {
          let data = doc.data() as TypeWithVersion<T>
          dataItems.push(data)
        }
        let { totalPages, nextPage, prevPage, pagingCounter, hasNextPage, hasPrevPage } =
          calculatePageResultStatistics({
            totalDocsCount,
            payloadLimit: payloadLimit ? payloadLimit : 0,
            page: page || 1,
            pagination: pagination || false,
          })
        console.log('found versions', versionCollectionName, dataItems)
        return {
          docs: dataItems,
          hasNextPage,
          hasPrevPage,
          limit: payloadLimit || 0,
          pagingCounter,
          totalDocs: totalDocsCount,
          totalPages,
          nextPage,
          page: page || 1,
          prevPage,
        }
      },
      async queryDrafts<T = TypeWithID>({
        collection: nonVersionCollectionName,
        limit: payloadLimit,
        locale,
        page,
        pagination,
        sort,
        select,
        where: payloadWhereQuery,
        joins,
      }: QueryDraftsArgs): Promise<PaginatedDocs<T>> {
        const versionCollectionName = nonVersionCollectionName + this.versionsSuffix
        console.log('trying to find drafts', versionCollectionName, { joins, locale, select })

        const colRef = (this.firestore as Firestore).collection(versionCollectionName)

        let firestoreQuery = colRef.limit(0);

        let collectionConfig = payload.collections[nonVersionCollectionName]?.config;

        if (!collectionConfig) {
          collectionConfig = payload.globals.config.find((global) => global.slug === nonVersionCollectionName) as unknown as SanitizedCollectionConfig;
        }

        if (!sort) {
          console.log('no sort given');
          if (collectionConfig?.defaultSort) {
            console.log('found defaultSort', collectionConfig);
            sort = collectionConfig?.defaultSort;
          }
        }

        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            versionCollectionName,
            collectionConfig,
            payloadWhereQuery,
            sort,
          )
        } else {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            versionCollectionName,
            collectionConfig,
            null,
            sort,
          )
        }

        firestoreQuery = firestoreQuery.where('latest', '==', true);

        let totalDocsCount = (await firestoreQuery.count().get()).data().count

        console.log('searching drafts', generateQueryJson(firestoreQuery))

        let offset = page || 1 > 1 ? (payloadLimit || 0) * ((page || 1) - 1) : 0

        if (offset > 0) {
          firestoreQuery = firestoreQuery.offset(offset);
        }
        if (payloadLimit) {
          // FIXME: offset in firestore means -> load everything until the limit + page and return just the last page.
          firestoreQuery = firestoreQuery.limit(payloadLimit);
        }

        let docs = await firestoreQuery.get()
        let dataItems = []

        for (let doc of docs.docs) {
          let data = doc.data() as TypeWithVersion<T>
          dataItems.push({
            id: data.parent,
            ...data.version,
            createdAt: data.createdAt,
            updatedAt: data.updatedAt,
          })
        }
        let { totalPages, nextPage, prevPage, pagingCounter, hasNextPage, hasPrevPage } =
          calculatePageResultStatistics({
            totalDocsCount,
            payloadLimit: payloadLimit ? payloadLimit : 0,
            page: page || 1,
            pagination: pagination || false,
          })
        return {
          docs: dataItems,
          hasNextPage,
          hasPrevPage,
          limit: payloadLimit || 0,
          pagingCounter,
          totalDocs: totalDocsCount,
          totalPages,
          nextPage,
          page: page || 1,
          prevPage,
        }
      },
      async updateGlobalVersion<T extends TypeWithID = TypeWithID>({
        global: payloadGlobalName,
        req,
        versionData,
        id,
        select,
        locale,
        where: payloadWhereQuery,
      }: UpdateGlobalVersionArgs<T>): Promise<TypeWithVersion<T>> {
        if (id) {
          return await this.updateVersion({
            collection: payloadGlobalName,
            req,
            versionData,
            
            id,
            locale,
          })
        }
        return await this.updateVersion({
          collection: payloadGlobalName,
          req,
          versionData,
          locale,
          where: payloadWhereQuery as Where,
        })
      },
      async updateOne({
        data,
        collection: collectionName,
        draft,
        locale,
        select,
        joins,
        options,
        req,
        id,
        where: payloadWhereQuery,
      }: UpdateOneArgs): Promise<any> {
        const colRef = (this.firestore as Firestore).collection(collectionName)
        console.log('Updating document', collectionName, 'with id', id, {locale, draft, select, joins, options, where: payloadWhereQuery}, 'and data', data)
        const docRef = colRef.doc('/' + id)
        // FIXME: do not ignore where!
        const updateData: Partial<any> = { ...data }
        await docRef.update(JSON.parse(JSON.stringify(updateData)))
        return { id: docRef.id, ...data }
      },
      updateVersion<T extends TypeWithID = TypeWithID>(
        args: UpdateVersionArgs<T>,
      ): Promise<TypeWithVersion<T>> {
        console.error('Function updateVersion not implemented.')
        throw new Error('Function updateVersion not implemented.')
      },
      count: async function ({
        collection: collectionName,
        locale,
        where: payloadWhereQuery,
      }: CountArgs): Promise<{ totalDocs: number }> {
        console.log('trying to count', collectionName, { locale, payloadWhereQuery })
        const colRef = (this.firestore as Firestore).collection(collectionName)

        let firestoreQuery = colRef.limit(0);

        let collectionConfig = payload.collections[collectionName]?.config;

        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            collectionName,
            collectionConfig,
            payloadWhereQuery,
          )
        }

        let totalDocsCount = (await firestoreQuery.count().get()).data().count
        console.log('counted ', collectionName, 'amount', totalDocsCount)

        return {
          totalDocs: totalDocsCount,
        }
      },
      createGlobal: async function <T extends Record<string, unknown> = any>({
        data,
        req,
        slug: payloadGlobalName,
      }: CreateGlobalArgs<T>): Promise<T> {
        console.log('creating global', payloadGlobalName, 'with data', data)
        const colRef = (this.firestore as Firestore).collection(payloadGlobalName)
        // FIXME: maybe we can change this to use the autogenerated value - but we need data.id to be searchable, too for where queries
        //data.id = payloadGlobalName
        //data.createdAt = data.createdAt || new Date().toISOString()
        //data.updatedAt = data.updatedAt || data.createdAt
        const docRef = colRef.doc('/' + payloadGlobalName)
        await docRef.set(JSON.parse(JSON.stringify(data)))
        return { id: docRef.id, ...data }
      },
      findGlobal: async function <T extends Record<string, unknown> = any>({
        slug: payloadGlobalName,
        req,
        select,
        locale,
        where: payloadWhereQuery,
      }: FindGlobalArgs): Promise<T> {
        console.log('findGlobal in', payloadGlobalName, 'where', payloadWhereQuery, 'and', {select, locale});
        let doc = this.findOne({
          collection: payloadGlobalName,
          req,
          select,
          locale,
          where: payloadWhereQuery,
        })
        if (doc !== null) {
          doc.globalType = payloadGlobalName
          return doc
        }

        return null
      },
      findOne: async function <T extends TypeWithID>({
        collection: payloadCollectionName,
        where: payloadWhereQuery,
        select,
        locale,
        joins,
      }: FindOneArgs): Promise<T | null> {
        const colRef = (this.firestore as Firestore).collection(payloadCollectionName)
        console.log('fetch one', payloadCollectionName, 'where', payloadWhereQuery, 'and', {joins, locale, select })

        let firestoreQuery = colRef.limit(1);
        let collectionConfig = payload.collections[payloadCollectionName]?.config;

        // FIXME: maybe we can optimize if we search for just "one" item by id
        if (payloadWhereQuery) {
          firestoreQuery = convertPayloadToFirestoreQuery(
            this.firestore as Firestore,
            payloadCollectionName,
            collectionConfig,
            payloadWhereQuery,
          )
          firestoreQuery = firestoreQuery.limit(1);
        }

        let docs = await firestoreQuery.get();
        // FIXME: ended (e.g. by using getDoc and ID reference)
        if (!docs.docs[0]) {
          return null
        }
        console.log('fetched ', payloadCollectionName, 'data', docs.docs[0].data())
        return docs.docs[0].data() as T
      },
      updateGlobal: function <T extends Record<string, unknown> = any>({
        data,
        req,
        select,
        slug: payloadGlobalName,
      }: UpdateGlobalArgs<T>): Promise<T> {
        // FIXME: the data is not stored in the latest item
        return this.updateOne({
          collection: payloadGlobalName,
          data,
          select, 
          req,
          id: payloadGlobalName,
        })
      },
      connect: async function (): Promise<void> {
          const app = initializeApp({
            projectId: process.env.FIRESTORE_PROJECT_ID,
            storageBucket: process.env.FIRESTORE_STORAGE_BUCKET,
            databaseURL: process.env.FIRESTORE_DATABASE_URL,
            serviceAccountId: process.env.FIRESTORE_SERVICE_ACCOUNT_ID,
            databaseAuthVariableOverride: process.env.FIRESTORE_DATABASE_AUTH_VARIABLE_OVERRIDE ? JSON.parse(process.env.FIRESTORE_DATABASE_AUTH_VARIABLE_OVERRIDE) : null,
            credential: applicationDefault(),
          });
        if (this.firestore) {
          console.log('terminate firestore');
          await (this.firestore as Firestore).terminate();
        }
        console.log('connecting firestore');
        this.firestore = getFirestore(app)
        if (process.env.FIRESTORE_EMULATOR_HOST) {
          this.firestore.settings({
            host: process.env.FIRESTORE_EMULATOR_HOST,
            ssl: false,
          });
          console.log('use firestore emulator');
        }
      },
      beginTransaction: async function (
        options?: Record<string, unknown>,
      ): Promise<null | number | string> {
        console.error('Function beginTransaction not implemented.')

        //throw new Error('Function beginTransaction not implemented.');
        return null
      },
      commitTransaction: async function (
        id: number | Promise<number | string> | string,
      ): Promise<void> {
        console.error('Function commitTransaction not implemented.')

        //throw new Error('Function commitTransaction not implemented.');
      },
      rollbackTransaction: async function (
        id: number | Promise<number | string> | string,
      ): Promise<void> {
        console.error('Function rollbackTransaction not implemented.')

        throw new Error('Function rollbackTransaction not implemented.')
      },
      upsert: function ({
        collection: payloadCollectionName,
        where: payloadWhereQuery,
        data,
        req,
        joins,
        select,
        locale,
      }: any): Promise<Document> {
        return this.updateOne({
          collection: payloadCollectionName,
          data,
          req,
          joins,
          select,
          locale,
          where: payloadWhereQuery,
        })
      },

      async dropDatabase({adapter}: {adapter: any}): Promise<void> {
        console.log('starting to dropDatabase database');
        for (let collectionConfig of (payload.config.collections || [])) {
          let collectionDocs = await (this.firestore as Firestore).collection(collectionConfig.slug).listDocuments();
          for (let doc of collectionDocs) {
            console.log('Deleting doc id:', doc.id, 'of', collectionConfig.slug);
            await doc.delete();
          }
        }
        for (let globalConfig of (payload.config.globals || [])) {
          let globalDocs = await (this.firestore as Firestore).collection(globalConfig.slug).listDocuments();
          for (let doc of globalDocs) {
            console.log('Deleting doc id:', doc.id, 'of', globalConfig.slug);
            await doc.delete();
          }
        }
        console.log('finished to dropDatabase database');
      },
      init: async function (): Promise<void> {
        console.error('Function init not implemented.')
      },
    };
  }

  return {
    defaultIDType,
    init: adapter,
  }
}
