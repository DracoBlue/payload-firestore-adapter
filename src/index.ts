import {
  type CountArgs,
  type CreateArgs,
  type CreateGlobalArgs,
  type CreateGlobalVersionArgs,
  type CreateVersionArgs,
  type DeleteManyArgs,
  type DeleteOneArgs,
  type DeleteVersionsArgs,
  type FindArgs,
  type FindGlobalArgs,
  type FindGlobalVersionsArgs,
  type FindOneArgs,
  type FindVersionsArgs,
  type PaginatedDocs,
  type QueryDraftsArgs,
  type SanitizedCollectionConfig,
  type TypeWithVersion,
  type UpdateGlobalArgs,
  type UpdateGlobalVersionArgs,
  type UpdateOneArgs,
  type UpdateVersionArgs,
  type TypeWithID,
  type Document,
  type Where,
  type BasePayload,
  type FieldBase,
  PayloadRequest,
} from 'payload'

import { Datastore, DatastoreRequest, Transaction } from '@google-cloud/datastore';
import { v4 as uuid } from 'uuid';

import { convertPayloadToFirestoreQuery } from './convertPayloadToFirestoreQuery'
import type { FirestoreAdapter } from './types'
import { RunQueryInfo } from '@google-cloud/datastore/build/src/query';
import { queryDatastoreCollectionByPayloadFilter } from './queryDatastoreCollectionByPayloadFilter';

export function firestoreAdapter({
  defaultIDType = 'text',
  versionsSuffix,
}: {
  defaultIDType?: 'number' | 'text'
  versionsSuffix?: string
}) {
  function adapter({ payload }: { payload: BasePayload }) {
    return {
      name: 'firestore',
      packageName: 'payload-firestore-adapter',
      sessions: {},
      payload,
      defaultIDType,
      versionsSuffix: versionsSuffix || '_v',
      async create({
        data,
        collection: collectionName,
        draft,
        select,
        locale,
        req,
      }: CreateArgs): Promise<Document> {
        console.log('creating', collectionName, 'with data', data, 'and', {locale, draft, select})
        let datastoreRequest = await this.getTransaction(req);

        // FIXME: maybe we can change this to use the autogenerated value - but we need data.id to be searchable, too for where queries
        data.id = data.id || crypto.randomUUID();
        data.createdAt = data.createdAt || new Date().toISOString()
        data.updatedAt = data.createdAt
        if (typeof data.document === 'undefined') {
          delete data.document
        }

        let fields = payload.collections[collectionName]?.config?.fields as FieldBase[];

        let prefillDefaultValues = (data, fields) => {
          for (let field of fields) {
            if (typeof data[field.name] === "undefined" && typeof field.defaultValue !== "undefined") {
              if (field.type === "point") {
                data[field.name] = {
                  type: 'Point',
                  coordinates: field.defaultValue
                };
              } else {
                data[field.name] = field.defaultValue;
              }
            }
            if (field.type === "group") {
              prefillDefaultValues(data[field.name], field.fields);
            }
            if (field.type === "array") {
              for (let pos in data[field.name]) {
                prefillDefaultValues(data[field.name][pos], field.fields);
              }
            }
          }
        };

        prefillDefaultValues(data, fields);

        let entity = {
          key: datastoreRequest.datastore.key([collectionName, data.id as string]),
          data: {
            ...JSON.parse(JSON.stringify(data))
          },
        };
      
        await datastoreRequest.insert(entity);

        return { id: data.id, ...data }
      },

      async createGlobalVersion<T extends TypeWithID = TypeWithID>({
        autosave,
        createdAt,
        parent,
        updatedAt,
        versionData,
        req,
        select,
        globalSlug: payloadGlobalName,
        publishedLocale,
        snapshot,
      }: CreateGlobalVersionArgs<T>): Promise<TypeWithVersion<T>> {
        return await this.createVersion({
          autosave,
          collectionSlug: payloadGlobalName,
          createdAt,
          parent: parent || payloadGlobalName,
          req,
          select,
          updatedAt,
          versionData,
          publishedLocale,
          snapshot,
        })
      },
      async createVersion<T extends TypeWithID = TypeWithID>({
        autosave,
        collectionSlug,
        createdAt,
        parent,
        select,
        req,
        publishedLocale,
        snapshot,
        updatedAt,
        versionData,
      }: CreateVersionArgs<T>): Promise<TypeWithVersion<T>> {
        console.log(
          'creating version',
          collectionSlug,
          'for parent',
          parent,
          'with data',
          versionData,
          {select, publishedLocale, snapshot}
        )
        // FIXME: maybe we can change this to use the autogenerated value - but we need data.id to be searchable, too for where queries
        let data: any = {
          id: crypto.randomUUID(),
          createdAt,
          updatedAt,
          parent,
          latest: true,
          version: versionData,
          autosave,
        }

        let datastoreRequest = await this.getTransaction(req);

        console.log('creating version at', collectionSlug + this.versionsSuffix, data)
        await datastoreRequest.insert({
          key: datastoreRequest.datastore.key([collectionSlug + this.versionsSuffix, data.id]),
          data: {
            ...JSON.parse(JSON.stringify(data))
          },
        })

        try {
          let [previousLatestVersionDocs] = await datastoreRequest.createQuery(collectionSlug + this.versionsSuffix).filter('parent', '=', parent).filter('latest', '=', true).run();

          for (let previousLatestVersionDoc of previousLatestVersionDocs) {
            if (previousLatestVersionDoc.id === data.id) {
              console.log('keep to latest for', previousLatestVersionDoc.id)
            } else {
              console.log('setting to nonlatest for', previousLatestVersionDoc.id)

              await datastoreRequest.update({
                key: previousLatestVersionDoc[datastoreRequest.datastore.KEY],
                data: {
                  latest: false,
                },
              });
            }
          }
        } catch (error) {
          console.error('fetch latest version doc', error);
        }

        return { id: data.id, version: versionData, createdAt, parent, updatedAt }
      },
      async deleteMany({
        collection: collectionName,
        joins,
        req,
        where: payloadQuery,
      }: DeleteManyArgs): Promise<void> {
        console.log('delete many from', collectionName,  {joins, where: payloadQuery});
        let datastoreRequest = await this.getTransaction(req);

        let collectionConfig = payload.collections[collectionName]?.config;

        console.log('fetch for deletion');
        // FIXME: should check for "in" with empty array!
        try {
          let result = await queryDatastoreCollectionByPayloadFilter({
            datastoreRequest: await this.getTransaction(req),
            collectionName,
            collectionConfig,
            payloadQuery,
            page: 1,
            pagination: false,
            payloadLimit: 0,
            payloadSort: [],
            countData: false,
            fetchData: true,
            fetchKeysOnly: true,
            skip: 0
          });
  
          let keys = result.docs.map((doc) => doc.key);

          if (keys.length) {
            await datastoreRequest.delete(keys);
          }
        } catch (error) {
          console.error('deletion error', error);
        }
      },
      async deleteOne({
        collection: collectionName,
        joins,
        select,
        req,
        where: payloadWhereQuery,
      }: DeleteOneArgs): Promise<any> {
        console.log('delete one from', collectionName, {joins, select, where: payloadWhereQuery});
        let datastoreRequest = await this.getTransaction(req);
        let collectionConfig = payload.collections[collectionName]?.config;

        // FIXME: maybe we can optimize if we search for just "one" item by id
        let [firestoreQuery, hasNodeConditions] = convertPayloadToFirestoreQuery(
          datastoreRequest,
          collectionName,
          collectionConfig,
          payloadWhereQuery ? payloadWhereQuery : null,
        );
        firestoreQuery = firestoreQuery.select('__key__').limit(1);

        let [docs, runQueryInfo] : [any[], RunQueryInfo] = await firestoreQuery.run();
        let doc = docs[0];

        await datastoreRequest.delete(doc[datastoreRequest.datastore.KEY]);

        return JSON.parse(JSON.stringify(doc));
      },
      async deleteVersions({
        collection: nonVersionCollectionName,
        where: payloadWhereQuery,
        req,
        locale,
        sort,
      }: DeleteVersionsArgs): Promise<void> {
        console.log('deleting versions', nonVersionCollectionName, payloadWhereQuery, 'and', {locale, sort});
        let datastoreRequest = await this.getTransaction(req);

        let versionCollectionName = nonVersionCollectionName + this.versionsSuffix
        let collectionConfig = payload.collections[nonVersionCollectionName]?.config;

        if (!collectionConfig) {
          collectionConfig = payload.globals.config.find((global) => global.slug === nonVersionCollectionName) as unknown as SanitizedCollectionConfig;
        }

        // FIXME: maybe we can optimize if we search for just "one" item by id
        let [firestoreQuery, hasNodeConditions] = convertPayloadToFirestoreQuery(
          datastoreRequest,
          versionCollectionName,
          collectionConfig,
          payloadWhereQuery ? payloadWhereQuery : null,
        )

        let [docs] = await firestoreQuery.run();
        if (docs.length) {
          console.log('delete versions', docs);
          let keys = docs.map((doc) => doc[datastoreRequest.datastore.KEY]);
          console.log('delete versions (keys)', keys);
          await datastoreRequest.delete(keys);
          console.log('deleted versions')
        }
      },
      async find<T = TypeWithID>({
        collection: collectionName,
        limit: payloadLimit,
        locale,
        page,
        pagination,
        skip,
        sort: payloadSort,
        select,
        versions,
        where: payloadQuery,
        joins,
        req,
        projection,
      }: FindArgs): Promise<PaginatedDocs<T>> {
        console.log('trying to find', collectionName, { joins, projection, versions, skip, locale, select })
        let collectionConfig = payload.collections[collectionName]?.config;
        let result = await queryDatastoreCollectionByPayloadFilter<T>({
          datastoreRequest: await this.getTransaction(req),
          collectionName,
          collectionConfig,
          payloadQuery,
          page,
          pagination,
          payloadLimit,
          payloadSort,
          locale,
          skip
        });
        console.log('fetched', collectionName, 'data', result.docs.length)
        return result;        
      },
      async findGlobalVersions<T = TypeWithID>({
        global: payloadGlobalName,
        req,
        limit,
        locale,
        page,
        select,
        pagination,
        skip,
        sort,
        where: payloadWhereQuery,
        versions,
      }: FindGlobalVersionsArgs): Promise<PaginatedDocs<TypeWithVersion<T>>> {
        return await this.findVersions({
          collection: payloadGlobalName,
          req,
          limit,
          locale,
          page,
          select,
          pagination,
          skip,
          sort,
          versions,
          where: payloadWhereQuery,
        })
      },
      async countGlobalVersions<T = TypeWithID>({
        global: payloadGlobalName,
        req,
        locale,
        where: payloadWhereQuery
      }: any): Promise<any> {
        return await this.countVersions({
          collection: payloadGlobalName,
          req,
          locale,
          where: payloadWhereQuery,
        })
      },      
      async countVersions<T = TypeWithID>({
        collection: nonVersionCollectionName,
        req,
        locale,
        where: payloadWhereQuery,
      }: any): Promise<any> {
        let versionCollectionName = nonVersionCollectionName + this.versionsSuffix
        console.log('trying to count versions', versionCollectionName, {locale})

        let collectionConfig = payload.collections[nonVersionCollectionName]?.config;

        if (!collectionConfig) {
          collectionConfig = payload.globals.config.find((global) => global.slug === nonVersionCollectionName) as unknown as SanitizedCollectionConfig;
        }

        let [countQuery, hasNodeConditions] = convertPayloadToFirestoreQuery(
          await this.getTransaction(req),
          versionCollectionName,
          collectionConfig,
          payloadWhereQuery ? payloadWhereQuery : null,
          null,
        );
        // FIXME: hasNodeConditions - means we need to filter in nodejs!
        countQuery.select('__key__').limit(-1).offset(-1);
        countQuery.orders = [];
        
        let [totalDocsKeys] = await countQuery.run();
        let totalDocsCount = totalDocsKeys.length;

        return {
          totalDocs: totalDocsCount
        }
      },
      async findVersions<T = TypeWithID>({
        collection: nonVersionCollectionName,
        limit: payloadLimit,
        locale,
        page,
        select,
        pagination,
        skip,
        req,
        sort: payloadSort,
        versions,
        where: payloadQuery,
      }: FindVersionsArgs): Promise<PaginatedDocs<TypeWithVersion<T>>> {
        let datastoreRequest = await this.getTransaction(req);
        let versionCollectionName = nonVersionCollectionName + this.versionsSuffix
        
        console.log('trying to find versions', versionCollectionName, {locale, versions, select, skip, page})

        let collectionConfig = payload.collections[nonVersionCollectionName]?.config;

        if (!collectionConfig) {
          collectionConfig = payload.globals.config.find((global) => global.slug === nonVersionCollectionName) as unknown as SanitizedCollectionConfig;
        }

        let result = await queryDatastoreCollectionByPayloadFilter({
          collectionConfig,
          datastoreRequest,
          collectionName: versionCollectionName,
          page,
          pagination,
          payloadLimit,
          payloadQuery,
          payloadSort,
          skip
        });

        result.docs = result.docs.map((doc) => {
          return {id: doc[datastoreRequest.datastore.KEY].name, ...doc}
        });

        console.log('found versions', versionCollectionName, result.docs.length)
        return result;
      },
      async queryDrafts<T = TypeWithID>({
        collection: nonVersionCollectionName,
        limit: payloadLimit,
        locale,
        page,
        pagination,
        sort: payloadSort,
        req,
        select,
        where: payloadQuery,
        joins
      }: QueryDraftsArgs): Promise<PaginatedDocs<T>> {
        const versionCollectionName = nonVersionCollectionName + this.versionsSuffix
        console.log('trying to find drafts', versionCollectionName, { joins, locale, select })

        let collectionConfig = payload.collections[nonVersionCollectionName]?.config;

        if (!collectionConfig) {
          collectionConfig = payload.globals.config.find((global) => global.slug === nonVersionCollectionName) as unknown as SanitizedCollectionConfig;
        }

        if (payloadQuery) {
          payloadQuery =  {
            and: [
              payloadQuery,
              { latest: { equals: true } }
            ]
          };
        } else {
          payloadQuery = { latest: { equals: true } };
        }

        let result = await queryDatastoreCollectionByPayloadFilter<T>({
          datastoreRequest: await this.getTransaction(req),
          collectionName: versionCollectionName,
          collectionConfig,
          payloadQuery: payloadQuery ? payloadQuery : null,
          page,
          pagination,
          payloadLimit,
          payloadSort,
          skip: 0
        });

        result.docs = result.docs.map((doc : TypeWithVersion<T>) => {
          return {
            id: doc.parent,
            ...doc.version,
            createdAt: doc.createdAt,
            updatedAt: doc.updatedAt,
          }
        })

        console.log('found drafts', versionCollectionName, 'data', result.docs.length);

        return result;
      },
      async updateGlobalVersion<T extends TypeWithID = TypeWithID>({
        global: payloadGlobalName,
        req,
        versionData,
        id,
        select,
        locale,
        where: payloadWhereQuery,
      }: UpdateGlobalVersionArgs<T>): Promise<TypeWithVersion<T>> {
        if (id) {
          return await this.updateVersion({
            collection: payloadGlobalName,
            req,
            versionData,
            
            id,
            locale,
          })
        }
        return await this.updateVersion({
          collection: payloadGlobalName,
          req,
          versionData,
          locale,
          where: payloadWhereQuery as Where,
        })
      },
      async updateOne({
        data,
        collection: collectionName,
        draft,
        locale,
        select,
        joins,
        options,
        req,
        id,
        where: payloadWhereQuery,
      }: UpdateOneArgs): Promise<any> {
        console.log('Updating document', collectionName, 'with id', id, {locale, draft, select, joins, options, where: payloadWhereQuery}, 'and data', data)
        let datastoreRequest = await this.getTransaction(req);
        await datastoreRequest.update({
          key: datastoreRequest.datastore.key([collectionName, id]),
          data: {
            id,
            ...data
          },
        })
        return { id, ...data }
      },
      updateVersion<T extends TypeWithID = TypeWithID>(
        args: UpdateVersionArgs<T>,
      ): Promise<TypeWithVersion<T>> {
        console.error('Function updateVersion not implemented.')
        throw new Error('Function updateVersion not implemented.')
      },
      count: async function ({
        collection: collectionName,
        locale,
        req,
        where: payloadQuery,
      }: CountArgs): Promise<{ totalDocs: number }> {
        console.log('trying to count', collectionName, { locale, payloadQuery })
        let collectionConfig = payload.collections[collectionName]?.config;

        let result = await queryDatastoreCollectionByPayloadFilter({
          datastoreRequest: await this.getTransaction(req),
          collectionName,
          collectionConfig,
          payloadQuery,
          page: 1,
          pagination: true,
          payloadLimit: 0,
          payloadSort: [],
          countData: true,
          fetchData: false,
          skip: 0
        });
        console.log('counted', collectionName, 'amount', result.totalDocs)

        return {
          totalDocs: result.totalDocs,
        }
      },
      createGlobal: async function <T extends Record<string, unknown> = any>({
        data,
        req,
        slug: payloadGlobalName,
      }: CreateGlobalArgs<T>): Promise<T> {
        console.log('creating global', payloadGlobalName, 'with data', data);
        let datastoreRequest = await this.getTransaction(req);
        //data.id = payloadGlobalName
        //data.createdAt = data.createdAt || new Date().toISOString()
        //data.updatedAt = data.updatedAt || data.createdAt
        await datastoreRequest.insert({
          key: datastoreRequest.datastore.key([payloadGlobalName, payloadGlobalName]),
          data: {
            ...JSON.parse(JSON.stringify(data))
          },
        });
        return { id: payloadGlobalName, ...data }
      },
      findGlobal: async function <T extends Record<string, unknown> = any>({
        slug: payloadGlobalName,
        req,
        select,
        locale,
        where: payloadWhereQuery,
      }: FindGlobalArgs): Promise<T> {
        console.log('findGlobal in', payloadGlobalName, 'where', payloadWhereQuery, 'and', {select, locale});
        let doc = this.findOne({
          collection: payloadGlobalName,
          req,
          select,
          locale,
          where: payloadWhereQuery,
        })
        if (doc !== null) {
          doc.globalType = payloadGlobalName
          return doc
        }

        return null
      },
      findOne: async function <T extends TypeWithID>({
        collection: payloadCollectionName,
        where: payloadWhereQuery,
        select,
        locale,
        req,
        joins,
      }: FindOneArgs): Promise<T | null> {
        console.log('fetch one', payloadCollectionName, 'where', payloadWhereQuery, 'and', {joins, locale, select })
        let datastoreRequest = await this.getTransaction(req);
        let firestoreQuery = datastoreRequest.createQuery(payloadCollectionName).limit(1);

        let collectionConfig = payload.collections[payloadCollectionName]?.config;
        let hasNodeConditions = false;

        // FIXME: maybe we can optimize if we search for just "one" item by id
        if (payloadWhereQuery) {
          [firestoreQuery, hasNodeConditions] = convertPayloadToFirestoreQuery(
            datastoreRequest,
            payloadCollectionName,
            collectionConfig,
            payloadWhereQuery,
          )
          // FIXME: if hasNodeConditions the limit 1 is not possible before filtering in nodejsÂ´
          firestoreQuery = firestoreQuery.limit(1);
        }

        let [docs] = await firestoreQuery.run();
        // FIXME: ended (e.g. by using getDoc and ID reference)
        if (!docs[0]) {
          console.log('did not find one', payloadCollectionName, 'data', {hasNodeConditions});
          let [allRows] = await (datastoreRequest.createQuery(payloadCollectionName).run());
          console.log(' all rows are', allRows);

          return null
        }
        console.log('fetched ', payloadCollectionName, 'data', docs[0])
        return ({id: docs[0][datastoreRequest.datastore.KEY].name, ...docs[0]} as T)
      },
      updateGlobal: function <T extends Record<string, unknown> = any>({
        data,
        req,
        select,
        slug: payloadGlobalName,
      }: UpdateGlobalArgs<T>): Promise<T> {
        // FIXME: the data is not stored in the latest item
        return this.updateOne({
          collection: payloadGlobalName,
          data,
          select, 
          req,
          id: payloadGlobalName,
        })
      },
      connect: async function (): Promise<void> {

        console.log('connecting firestore');

        this.firestore = new Datastore({
          projectId: process.env.FIRESTORE_PROJECT_ID,
          databaseId: process.env.FIRESTORE_DATABASE_ID,
        }) as any;
      },
      getTransaction: async function (req?: Partial<PayloadRequest>) : Promise<DatastoreRequest> {
        if (!req?.transactionID) {
          return (this.firestore as Datastore) as unknown as DatastoreRequest;
        }
        let transactionID = await req.transactionID;

        if (!this.sessions[transactionID]) {
          return (this.firestore as Datastore) as unknown as DatastoreRequest;
        }

        return this.sessions[await req.transactionID] as DatastoreRequest;
      },
      beginTransaction: async function (
        options?: Record<string, unknown>,
      ): Promise<null | number | string> {
        try {
          let transaction = (this.firestore as Datastore).transaction();
          let transactionID = uuid();
          console.log('create transaction', transactionID);

          await transaction.run();
  
          this.sessions[transactionID] = transaction;
          return transactionID
        } catch (error) {
          this.payload.logger.error({ error, msg: `Error: cannot begin transaction: ${error.message}` })
          process.exit(1)
        }
      },
      commitTransaction: async function (
        id: number | Promise<number | string> | string,
      ): Promise<void> {
        let transactionID = await id;
        console.log('commit transaction', id);

        if (!this.sessions[transactionID]) {
          return 
        }

        let transaction = this.sessions[transactionID] as Transaction;
        await transaction.commit();
        console.log('committed transaction', transactionID);
        this.sessions[transactionID] = null;

      },
      rollbackTransaction: async function (
        id: number | Promise<number | string> | string,
      ): Promise<void> {
        let transactionID = await id;
        console.log('rollback transaction', transactionID);

        if (!this.sessions[transactionID]) {
          return 
        }

        let transaction = this.sessions[transactionID] as Transaction;
        await transaction.rollback();
        console.log('rollbacked transaction', transactionID);
        this.sessions[transactionID] = null;
      },
      upsert: async function ({
        collection: payloadCollectionName,
        where: payloadWhereQuery,
        data,
        req,
        joins,
        select,
        locale,
      }: any): Promise<Document> {
        let id = data?.id;
        if (!id) {
          let existingDoc = await this.findOne({
            collection: payloadCollectionName,
            where: payloadWhereQuery,
            select,
            locale,
            req,
            joins,    
          });
          if (existingDoc) {
            id = existingDoc.id;
          }
        }
        if (!id) {
          return await this.create({
            collection: payloadCollectionName,
            data,
            draft: false,
            select,
            locale,
            req
          });
        }
        return await this.updateOne({
          collection: payloadCollectionName,
          data,
          id,
          req,
          joins,
          select,
          locale,
          where: payloadWhereQuery,
        })
      },

      async dropDatabase({adapter}: {adapter: any}): Promise<void> {
        console.log('starting to dropDatabase database');
        for (let collectionConfig of (payload.config.collections || [])) {
          let [collectionDocs] = await (this.firestore as Datastore).createQuery(collectionConfig.slug).select('__key__').run();
          if (collectionDocs.length) {
            await (this.firestore as Datastore).delete(collectionDocs.map((doc) => doc[this.firestore.KEY]));
          }
        }
        for (let globalConfig of (payload.config.globals || [])) {
          let [globalDocs] = await (this.firestore as Datastore).createQuery(globalConfig.slug).select('__key__').run();
          if (globalDocs.length) {
            await (this.firestore as Datastore).delete(globalDocs.map((doc) => doc[this.firestore.KEY]));
          }
        }
        console.log('finished to dropDatabase database');
      },
      init: async function (): Promise<void> {
        console.error('Function init not implemented.')
      },
      destroy: async function (): Promise<void> {
        console.error('Function destroy not implemented.')
      },
    };
  }

  return {
    defaultIDType,
    init: adapter,
  }
}
